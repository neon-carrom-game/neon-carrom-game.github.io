<!DOCTYPE html>
<html lang="en" class="noselect">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Experience the thrill of Neon Carrom, crafted by Sourabh Suneja! Enjoy vibrant neon visuals, smooth striker physics, and exciting gameplay in both single-player mode against smart AI and two-player mode with a friend. Fast, fun, and addictive!">
      <meta name="theme-color" content="#000000">
      <!-- PWA Meta Tags -->
      <meta name="application-name" content="Neon Carrom">
      <meta name="apple-mobile-web-app-capable" content="yes">
      <meta name="apple-mobile-web-app-status-bar-style" content="default">
      <meta name="apple-mobile-web-app-title" content="Neon Carrom">
      <meta name="format-detection" content="telephone=no">
      <meta name="mobile-web-app-capable" content="yes">
      <meta name="msapplication-config" content="browserconfig.xml">
      <meta name="msapplication-TileColor" content="#000000">
      <meta name="msapplication-tap-highlight" content="no">
      <!-- PWA Manifest -->
      <link rel="manifest" href="manifest.json">
      <!-- Favicons and Icons -->
      <link rel="icon" type="image/x-icon" href="favicon.ico">
      <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
      <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
      <link rel="apple-touch-icon" href="apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.png">
      <link rel="icon" type="image/png" sizes="512x512" href="android-chrome-512x512.png">
    <title>Neon Carrom</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #050505;
            --neon-blue: #00f3ff;
            --neon-pink: #ff00cc;
            --neon-yellow: #ffee00;
            --glass-bg: rgba(20, 20, 20, 0.6);
            --border-glow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue);
            --text-glow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            max-height: 999999px;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            /* Retro-wave Grid Background */
            background-image: 
                linear-gradient(rgba(0, 243, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 0, 204, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            background-position: center;
            font-family: 'Orbitron', sans-serif; /* Switched primary font to Sci-Fi */
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            text-transform: uppercase;
        }

        /* Vignette overlay for atmosphere */
        body::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, #000 100%);
            pointer-events: none;
            z-index: 1;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            z-index: 10;
        }

        .score-board {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 650px;
            margin: 10px auto;
        }

        .player-score {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 8px;
            border: 2px solid #333;
            backdrop-filter: blur(10px);
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            min-width: 140px;
        }

        /* Player 1 Specifics (Pink Theme) */
        #p1-score-box {
            border-color: rgba(255, 0, 204, 0.3);
            color: #fff;
        }
        #p1-score-box.active {
            border-color: var(--neon-pink);
            box-shadow: 0 0 15px var(--neon-pink), inset 0 0 10px rgba(255, 0, 204, 0.2);
            transform: scale(1.05);
        }
        #p1-score-box h3 { color: var(--neon-pink); }

        /* Player 2 Specifics (Blue Theme) */
        #p2-score-box {
            border-color: rgba(0, 243, 255, 0.3);
            color: #fff;
        }
        #p2-score-box.active {
            border-color: var(--neon-blue);
            box-shadow: 0 0 15px var(--neon-blue), inset 0 0 10px rgba(0, 243, 255, 0.2);
            transform: scale(1.05);
        }
        #p2-score-box h3 { color: var(--neon-blue); }

        .player-score h3 {
            margin: 0 0 5px 0;
            font-size: 0.7rem;
            letter-spacing: 2px;
            text-shadow: 0 0 5px currentColor;
        }

        .player-score span {
            font-size: 2rem;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        #turn-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--accent);
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 20px var(--neon-yellow), 0 0 40px var(--neon-yellow);
            white-space: nowrap;
            letter-spacing: 5px;
            z-index: 15;
            pointer-events: none;
        }

        /* Menus */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 30px;
            color: #fff;
            text-align: center;
            /* Multi-color neon gradient text */
            background: linear-gradient(to right, var(--neon-pink), #fff, var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255,255,255,0.4);
            letter-spacing: 4px;
        }

        .btn {
            background: transparent;
            border: 2px solid var(--neon-blue);
            padding: 18px 40px;
            margin: 15px;
            border-radius: 4px; /* Slightly squared for tech look */
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 3px;
            width: 280px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
        }

        .btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px var(--neon-blue);
            transform: scale(1.05);
        }

        /* Alternate color for second button */
        .btn:nth-of-type(2) {
            border-color: var(--neon-pink);
            color: var(--neon-pink);
            box-shadow: 0 0 10px rgba(255, 0, 204, 0.2);
        }
        .btn:nth-of-type(2):hover {
            background: var(--neon-pink);
            color: #000;
            box-shadow: 0 0 30px var(--neon-pink);
        }

        /* Game Container & Canvas */
        #game-container {
            position: relative;
            border-radius: 20px;
            padding: 5px;
            /* Outer Neon Ring */
            box-shadow: 
                0 0 20px var(--neon-blue), 
                0 0 60px var(--neon-pink);
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink));
            z-index: 5;
        }

        canvas {
            border-radius: 16px;
            cursor: crosshair;
            display: block;
            /* THE MAGIC FILTER: 
               This inverts the wood colors (Beige/Brown) from the JS 
               turning them into Dark Blue/Cyan automatically. 
               It gives a dark mode look without changing the JS logic.
            */
            /*filter: invert(1) hue-rotate(180deg) brightness(1.2) contrast(1.1);*/
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: var(--neon-blue);
            font-size: 0.8rem;
            letter-spacing: 2px;
            opacity: 0.8;
            text-shadow: 0 0 5px var(--neon-blue);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; text-shadow: 0 0 15px var(--neon-blue); }
            100% { opacity: 0.5; }
        }
    </style>

</head>
<body>

    <div id="ui-layer">
        <div class="score-board">
            <div id="p1-score-box" class="player-score active">
                <h3>PLAYER 1</h3>
                <span id="score-p1">0</span>
            </div>
            <div id="p2-score-box" class="player-score">
                <h3 id="p2-name">PLAYER 2</h3>
                <span id="score-p2">0</span>
            </div>
        </div>
        <div id="turn-indicator">YOUR TURN</div>
        <div class="controls-hint" id="controls-hint">Drag Striker to Position<br>Pull Back to Shoot</div>
    </div>

    <div id="main-menu" class="modal">
        <h1>NEON CARROM</h1>
        <button class="btn" onclick="startGame('ai')">1 Player (vs AI)</button>
        <button class="btn" onclick="startGame('pvp')">2 Players</button>
    </div>

    <div id="game-over" class="modal hidden">
        <h1 id="winner-text">PLAYER 1 WINS!</h1>
        <p style="margin-bottom: 20px; color: #aaa;">Final Score</p>
        <h2 id="final-score" style="font-family: 'Orbitron'; margin-bottom: 30px;">10 - 5</h2>
        <button class="btn" onclick="location.reload()">Play Again</button>
    </div>

    <div id="game-container">
        <canvas id="carromBoard"></canvas>
    </div>

<script>
/**
 * Game Configuration & State
 */
const canvas = document.getElementById('carromBoard');
const ctx = canvas.getContext('2d');
const uiElements = {
    p1Box: document.getElementById('p1-score-box'),
    p2Box: document.getElementById('p2-score-box'),
    scoreP1: document.getElementById('score-p1'),
    scoreP2: document.getElementById('score-p2'),
    p2Name: document.getElementById('p2-name'),
    turnText: document.getElementById('turn-indicator'),
    hint: document.getElementById('controls-hint'),
    mainMenu: document.getElementById('main-menu'),
    gameOver: document.getElementById('game-over'),
    winnerText: document.getElementById('winner-text'),
    finalScore: document.getElementById('final-score')
};

// Physics Constants
const FRICTION = 0.982;
const WALL_BOUNCE = 0.7;
const POCKET_RADIUS_RATIO = 0.06;
const COIN_RADIUS_RATIO = 0.025;
const STRIKER_RADIUS_RATIO = 0.035;

let gameState = {
    mode: null, // 'ai' or 'pvp'
    turn: 0, // 0 = Player 1 (Bottom), 1 = Player 2/AI (Top)
    phase: 'place', // 'place' (moving striker), 'aim' (pulling back), 'shoot' (moving)
    pieces: [],
    striker: null,
    pockets: [],
    score: [0, 0],
    particles: [],
    boardSize: 0,
    isAnimating: false
};

let input = {
    isDown: false,
    startX: 0,
    startY: 0,
    currX: 0,
    currY: 0
};

// Sounds (Synthesized beep for single file portability)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    if (type === 'hit') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    } else if (type === 'pocket') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    }
}

/**
 * Classes
 */
class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(s) { return new Vector(this.x * s, this.y * s); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { let m = this.mag(); return m === 0 ? new Vector(0,0) : new Vector(this.x/m, this.y/m); }
    dot(v) { return this.x * v.x + this.y * v.y; }
}

class Particle {
    constructor(x, y, color) {
        this.pos = new Vector(x, y);
        this.vel = new Vector((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
        this.life = 1.0;
        this.color = color;
    }
    update() {
        this.pos = this.pos.add(this.vel);
        this.life -= 0.05;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Piece {
    constructor(x, y, type) { // type: 'white', 'black', 'queen', 'striker'
        this.pos = new Vector(x, y);
        this.vel = new Vector(0, 0);
        this.type = type;
        this.mass = type === 'striker' ? 2 : 1;
        this.radius = type === 'striker' ? gameState.boardSize * STRIKER_RADIUS_RATIO : gameState.boardSize * COIN_RADIUS_RATIO;
        this.pocketed = false;
    }

    draw() {
        if (this.pocketed) return;
        
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
        
        let grad = ctx.createRadialGradient(this.pos.x - this.radius/3, this.pos.y - this.radius/3, this.radius/10, this.pos.x, this.pos.y, this.radius);
        
        if (this.type === 'white') {
            grad.addColorStop(0, '#fff');
            grad.addColorStop(1, '#ccc');
        } else if (this.type === 'black') {
            grad.addColorStop(0, '#555');
            grad.addColorStop(1, '#111');
        } else if (this.type === 'queen') {
            grad.addColorStop(0, '#ffcc00');
            grad.addColorStop(1, '#ff6600');
        } else if (this.type === 'striker') {
            grad.addColorStop(0, '#fffacd');
            grad.addColorStop(1, '#f0e68c');
            // Striker ring
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffff00';
        }

        ctx.fillStyle = grad;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Detail ring
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    move() {
        if (this.pocketed) return;

        this.pos = this.pos.add(this.vel);
        this.vel = this.vel.mult(FRICTION);

        // Stop if too slow
        if (this.vel.mag() < 0.1) this.vel = new Vector(0,0);

        // Wall collisions
        const boardLimit = gameState.boardSize;
        const padding = boardLimit * 0.04; // Inside the wooden frame

        if (this.pos.x - this.radius < padding) {
            this.pos.x = padding + this.radius;
            this.vel.x *= -1 * WALL_BOUNCE;
            playSound('hit');
        }
        if (this.pos.x + this.radius > boardLimit - padding) {
            this.pos.x = boardLimit - padding - this.radius;
            this.vel.x *= -1 * WALL_BOUNCE;
            playSound('hit');
        }
        if (this.pos.y - this.radius < padding) {
            this.pos.y = padding + this.radius;
            this.vel.y *= -1 * WALL_BOUNCE;
            playSound('hit');
        }
        if (this.pos.y + this.radius > boardLimit - padding) {
            this.pos.y = boardLimit - padding - this.radius;
            this.vel.y *= -1 * WALL_BOUNCE;
            playSound('hit');
        }
    }
}

/**
 * Game Logic Functions
 */

function resize() {
    // Keep board square and fitting within screen
    const size = Math.min(window.innerWidth, window.innerHeight) * 0.95;
    canvas.width = size;
    canvas.height = size;
    gameState.boardSize = size;
    
    // Resize entities if game is running (simple rescale)
    // For simplicity in this single file, we just re-setup board on strict resize or rely on relative math
    // A full production game would scale vectors. Here we'll just center things.
}

function initBoard() {
    resize();
    const c = gameState.boardSize / 2;
    gameState.pieces = [];
    
    // Create Pockets
    const pR = gameState.boardSize * POCKET_RADIUS_RATIO;
    gameState.pockets = [
        new Vector(pR/1.5, pR/1.5), // Top Left
        new Vector(gameState.boardSize - pR/1.5, pR/1.5), // Top Right
        new Vector(gameState.boardSize - pR/1.5, gameState.boardSize - pR/1.5), // Bottom Right
        new Vector(pR/1.5, gameState.boardSize - pR/1.5) // Bottom Left
    ];

    // Arrange Coins (Flower pattern)
    const r = gameState.boardSize * COIN_RADIUS_RATIO * 2.1; // Distance between centers
    
    // Queen
    gameState.pieces.push(new Piece(c, c, 'queen'));

    // Inner Circle (6)
    for(let i=0; i<6; i++) {
        let angle = i * Math.PI / 3;
        let type = (i % 2 === 0) ? 'white' : 'black'; // Alternating
        gameState.pieces.push(new Piece(c + Math.cos(angle)*r, c + Math.sin(angle)*r, type));
    }

    // Outer Circle (12)
    // Note: Standard carrom setup is slightly complex, this is a simplified symmetric setup
    const r2 = r * 2; // Roughly
    // Adjusting specifically for standard look: 
    // Usually outer circle has white-white-black-white-white-black pattern or similar.
    // We will do alternating for balance in this simplified version.
    for(let i=0; i<12; i++) {
        let angle = i * Math.PI / 6;
        let type = 'black'; 
        // Create a balanced pattern
        if (i===0 || i===1 || i===4 || i===5 || i===8 || i===9) type = 'white';
        else type = 'black';
        
        gameState.pieces.push(new Piece(c + Math.cos(angle)*1.732*r, c + Math.sin(angle)*1.732*r, type));
    }

    // Striker
    resetStriker();
}

function resetStriker() {
    const margin = gameState.boardSize * 0.15;
    const y = gameState.turn === 0 
        ? gameState.boardSize - margin // Player 1 (Bottom)
        : margin; // Player 2 (Top)
    
    gameState.striker = new Piece(gameState.boardSize / 2, y, 'striker');
    gameState.phase = 'place';
    
    // AI Turn Trigger
    if(gameState.mode === 'ai' && gameState.turn === 1) {
        setTimeout(playAITurn, 1000);
    }
}

function startGame(mode) {
    gameState.mode = mode;
    gameState.score = [0, 0];
    gameState.turn = 0;
    gameState.particles = [];
    
    uiElements.mainMenu.classList.add('hidden');
    uiElements.gameOver.classList.add('hidden');
    uiElements.p2Name.innerText = mode === 'ai' ? "COMPUTER" : "PLAYER 2";
    
    updateScoreUI();
    initBoard();
    updateTurnUI();
    
    gameState.isAnimating = true;
    requestAnimationFrame(gameLoop);
}

function updateTurnUI() {
    uiElements.p1Box.classList.toggle('active', gameState.turn === 0);
    uiElements.p2Box.classList.toggle('active', gameState.turn === 1);
    
    let text = "";
    if (gameState.mode === 'ai') {
        text = gameState.turn === 0 ? "YOUR TURN" : "AI THINKING...";
    } else {
        text = gameState.turn === 0 ? "PLAYER 1" : "PLAYER 2";
    }
    
    uiElements.turnText.innerText = text;
    uiElements.turnText.style.opacity = 1;
    setTimeout(() => uiElements.turnText.style.opacity = 0, 1500);
}

function updateScoreUI() {
    uiElements.scoreP1.innerText = gameState.score[0];
    uiElements.scoreP2.innerText = gameState.score[1];
}

/**
 * AI Logic
 */
function playAITurn() {
    if(gameState.turn !== 1 || gameState.phase !== 'place') return;

    // Simple AI Heuristic
    const striker = gameState.striker;
    const pieces = gameState.pieces.filter(p => !p.pocketed && (p.type === 'black' || p.type === 'queen'));
    
    if (pieces.length === 0) {
        // No targets, just shoot randomly
        shootStriker(new Vector((Math.random()-0.5)*20, 20));
        return;
    }

    // Find closest target
    let target = pieces[0];
    let minDist = 9999;
    pieces.forEach(p => {
        const d = p.pos.sub(striker.pos).mag();
        if(d < minDist) { minDist = d; target = p; }
    });

    // Move striker to a somewhat random x position to simulate human variation
    striker.pos.x = (gameState.boardSize * 0.2) + Math.random() * (gameState.boardSize * 0.6);

    // Aim
    const angleVector = target.pos.sub(striker.pos).normalize();
    const power = 15 + Math.random() * 15; // Random power

    // Delay to simulate thinking, then shoot
    gameState.phase = 'shoot'; // Lock input
    setTimeout(() => {
        shootStriker(angleVector.mult(power));
    }, 800);
}

function shootStriker(velocity) {
    gameState.striker.vel = velocity;
    gameState.phase = 'play';
    uiElements.hint.style.opacity = 0;
}

/**
 * Physics & Loop
 */
function resolveCollisions() {
    const all = [...gameState.pieces, gameState.striker];
    
    for (let i = 0; i < all.length; i++) {
        for (let j = i + 1; j < all.length; j++) {
            let p1 = all[i];
            let p2 = all[j];
            
            if (p1.pocketed || p2.pocketed) continue;

            let distVec = p1.pos.sub(p2.pos);
            let dist = distVec.mag();
            let minDist = p1.radius + p2.radius;

            if (dist < minDist) {
                // Collision detected
                playSound('hit');

                // Create particles
                let midX = (p1.pos.x + p2.pos.x) / 2;
                let midY = (p1.pos.y + p2.pos.y) / 2;
                for(let k=0; k<5; k++) gameState.particles.push(new Particle(midX, midY, '#fff'));

                // Resolve Overlap (prevent sticking)
                let overlap = minDist - dist;
                let pushVec = distVec.normalize().mult(overlap / 2);
                p1.pos = p1.pos.add(pushVec);
                p2.pos = p2.pos.sub(pushVec);

                // Elastic Collision
                let normal = distVec.normalize();
                let tangent = new Vector(-normal.y, normal.x);

                let dpTan1 = p1.vel.dot(tangent);
                let dpTan2 = p2.vel.dot(tangent);

                let dpNorm1 = p1.vel.dot(normal);
                let dpNorm2 = p2.vel.dot(normal);

                let m1 = (dpNorm1 * (p1.mass - p2.mass) + 2 * p2.mass * dpNorm2) / (p1.mass + p2.mass);
                let m2 = (dpNorm2 * (p2.mass - p1.mass) + 2 * p1.mass * dpNorm1) / (p1.mass + p2.mass);

                p1.vel = tangent.mult(dpTan1).add(normal.mult(m1));
                p2.vel = tangent.mult(dpTan2).add(normal.mult(m2));
            }
        }
    }
}

function checkPockets() {
    const pocketRadius = gameState.boardSize * POCKET_RADIUS_RATIO;
    const all = [...gameState.pieces, gameState.striker];

    all.forEach(p => {
        if(p.pocketed) return;
        gameState.pockets.forEach(pocket => {
            if (p.pos.sub(pocket).mag() < pocketRadius) {
                p.pocketed = true;
                p.vel = new Vector(0,0);
                playSound('pocket');
                
                if (p.type === 'striker') {
                    handleStrikerFoul();
                } else {
                    handleScore(p);
                }
            }
        });
    });
}

function handleScore(piece) {
    let points = 0;
    if (piece.type === 'white') points = 10; // White usually for P1
    if (piece.type === 'black') points = 20; // Black usually for P2
    if (piece.type === 'queen') points = 50;

    // Simplified scoring: If you pocket ANY coin, you get points.
    // In real carrom, you only get points for your color.
    // For this arcade version: White = 10pts, Black = 20pts (harder), Queen = 50.
    
    gameState.score[gameState.turn] += points;
    updateScoreUI();
    
    // Check Win Condition
    const remaining = gameState.pieces.filter(p => !p.pocketed);
    if(remaining.length === 0) {
        gameOver();
    }
}

function handleStrikerFoul() {
    gameState.score[gameState.turn] = Math.max(0, gameState.score[gameState.turn] - 10);
    updateScoreUI();
    // In a full game, return a coin to board. Here we just punish score.
}

function gameOver() {
    gameState.isAnimating = false;
    uiElements.gameOver.classList.remove('hidden');
    let winner = gameState.score[0] > gameState.score[1] ? "PLAYER 1" : uiElements.p2Name.innerText;
    if (gameState.score[0] === gameState.score[1]) winner = "DRAW";
    uiElements.winnerText.innerText = winner + (winner === "DRAW" ? "" : " WINS!");
    uiElements.finalScore.innerText = `${gameState.score[0]} - ${gameState.score[1]}`;
}

function checkTurnEnd() {
    // Check if everything stopped moving
    const moving = [...gameState.pieces, gameState.striker].some(p => !p.pocketed && p.vel.mag() > 0.1);
    
    if(!moving && gameState.phase === 'play') {
        // Turn ended
        if (gameState.striker.pocketed) {
            // Respawn striker if fouled
            gameState.striker.pocketed = false; 
        }
        
        gameState.turn = 1 - gameState.turn; // Switch turn
        resetStriker();
        updateTurnUI();
        uiElements.hint.style.opacity = 1;
    }
}

function drawBoard() {
    const size = gameState.boardSize;
    
    // Board Base
    ctx.fillStyle = '#f3e5ab'; // Wood
    ctx.fillRect(0, 0, size, size);

    // Frame
    const frame = size * 0.04;
    ctx.fillStyle = '#5d4037';
    ctx.fillRect(0, 0, size, frame); // Top
    ctx.fillRect(0, size-frame, size, frame); // Bottom
    ctx.fillRect(0, 0, frame, size); // Left
    ctx.fillRect(size-frame, 0, frame, size); // Right

    // Pattern (Center Design)
    ctx.strokeStyle = '#a52a2a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(size/2, size/2, size * 0.18, 0, Math.PI*2);
    ctx.stroke();
    
    // Baselines
    ctx.strokeStyle = '#333';
    const margin = size * 0.15;
    // Top Line
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(size-margin, margin);
    ctx.stroke();
    // Bottom Line
    ctx.beginPath();
    ctx.moveTo(margin, size-margin);
    ctx.lineTo(size-margin, size-margin);
    ctx.stroke();

    // Pockets
    ctx.fillStyle = '#111';
    gameState.pockets.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, size * POCKET_RADIUS_RATIO, 0, Math.PI*2);
        ctx.fill();
        // Pocket shading
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 10;
        ctx.stroke();
        ctx.shadowBlur = 0;
    });
}

function drawAim() {
    if (gameState.phase !== 'aim') return;
    
    const s = gameState.striker;
    const pullVec = new Vector(input.startX - input.currX, input.startY - input.currY);
    
    // Draw Aim Line (Inverse of pull)
    ctx.beginPath();
    ctx.moveTo(s.pos.x, s.pos.y);
    const aimEnd = s.pos.add(pullVec.mult(3)); // Extend visual line
    ctx.lineTo(aimEnd.x, aimEnd.y);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw Power Circle
    ctx.beginPath();
    ctx.arc(s.pos.x, s.pos.y, s.radius + pullVec.mag(), 0, Math.PI*2);
    ctx.strokeStyle = `rgba(255, ${255 - Math.min(pullVec.mag()*5, 255)}, 0, 0.5)`; // Green to Red
    ctx.lineWidth = 3;
    ctx.stroke();
}

function gameLoop() {
    if(!gameState.isAnimating) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawBoard();
    
    // Updates
    if (gameState.phase === 'play') {
        [...gameState.pieces, gameState.striker].forEach(p => p.move());
        resolveCollisions();
        checkPockets();
        checkTurnEnd();
    }

    // Particles
    for(let i=gameState.particles.length-1; i>=0; i--) {
        let p = gameState.particles[i];
        p.update();
        p.draw(ctx);
        if(p.life <= 0) gameState.particles.splice(i, 1);
    }

    // Draw Pieces
    gameState.pieces.forEach(p => p.draw());
    if(!gameState.striker.pocketed) gameState.striker.draw();

    // Draw UI Helpers
    if(gameState.phase === 'aim') drawAim();

    requestAnimationFrame(gameLoop);
}

/**
 * Input Handling
 */
function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return {
        x: clientX - rect.left,
        y: clientY - rect.top
    };
}

function handleStart(e) {
    if (gameState.mode === 'ai' && gameState.turn === 1) return; // Wait for AI
    if (gameState.phase === 'play') return;

    const pos = getPos(e);
    
    // Check if clicking on striker
    const dist = new Vector(pos.x, pos.y).sub(gameState.striker.pos).mag();
    
    if (dist < gameState.striker.radius * 2) {
        input.isDown = true;
        input.startX = pos.x;
        input.startY = pos.y;
        input.currX = pos.x;
        input.currY = pos.y;
        
        // If clicking exactly on striker during 'place' phase, switch to 'aim'
        if(gameState.phase === 'place') {
             // Logic handled in Move: if drag is horizontal, move striker. If drag is vertical, start aim.
        }
    }
}

function handleMove(e) {
    if (!input.isDown) return;
    e.preventDefault(); // Prevent scroll on touch
    
    const pos = getPos(e);
    input.currX = pos.x;
    input.currY = pos.y;

    if (gameState.phase === 'place') {
        // Constraint movement to baseline
        const dx = Math.abs(input.currX - input.startX);
        const dy = Math.abs(input.currY - input.startY);
        
        // If moving mostly horizontally, slide the striker
        if (dx > dy && dy < 30) {
            let newX = pos.x;
            const margin = gameState.boardSize * 0.08;
            if(newX < margin) newX = margin;
            if(newX > gameState.boardSize - margin) newX = gameState.boardSize - margin;
            gameState.striker.pos.x = newX;
            // Reset start for subsequent aims
            input.startX = newX; 
        } 
        // If dragged down/up significantly, switch to aim mode
        else if (dy > 20) {
            gameState.phase = 'aim';
        }
    }
}

function handleEnd(e) {
    if (!input.isDown) return;
    input.isDown = false;

    if (gameState.phase === 'aim') {
        const pullVec = new Vector(input.startX - input.currX, input.startY - input.currY);
        const mag = pullVec.mag();
        
        if (mag > 20) {
            // Shoot
            let power = Math.min(mag, 150) * 0.35; // Cap power
            gameState.striker.vel = pullVec.normalize().mult(power);
            gameState.phase = 'play';
            uiElements.hint.style.opacity = 0;
        } else {
            // Cancel shot, return to place
            gameState.phase = 'place';
        }
    }
}

// Event Listeners
canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('touchstart', handleStart, {passive: false});
canvas.addEventListener('touchmove', handleMove, {passive: false});
canvas.addEventListener('touchend', handleEnd);

window.addEventListener('resize', () => {
    resize();
    drawBoard(); // Redraw static background if needed
});

if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/sw.js");
}

// Initial Init
resize();

</script>
</body>
</html>
